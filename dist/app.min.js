function getConstants() {
    return {
        errors: {
            '400': 'Bad Request',
            '401': 'Unauthorized',
            '402': 'Payment Required',
            '403': 'Forbidden',
            '404': 'Not Found',
            '405': 'Method Not Allowed',
            '406': 'Not Acceptable',
            '407': 'Proxy Authentication Required',
            '408': 'Request Timeout',
            '409': 'Conflict',
            '410': 'Gone',
            '411': 'Length Required',
            '412': 'Precondition Failed',
            '413': 'Payload Too Large',
            '414': 'URI Too Long',
            '415': 'Unsupported Media Type',
            '416': 'Range Not Satisfiable',
            '417': 'Expectation Failed',
            '418': "I'm a teapot",
        },
        hands: [
            ['Lose', 0],
            ['Jacks or Better', 1],
            ['Two Pair', 2],
            ['Three of a Kind', 3],
            ['Straight', 4],
            ['Flush', 6],
            ['Full House', 9],
            ['Four of a Kind', 25],
            ['Straight Flush', 50],
            ['Royal Flush', 800],
        ],
        ranks: [
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9',
            't',
            'j',
            'q',
            'k',
            'a',
        ],
        suits: ['s', 'h', 'c', 'd'],
        colors: {
            's': '#1F191B',
            'c': '#1F191B',
            'h': '#CB1728',
            'd': '#CB1728',
        },
        stringMap: {
            'as': '🂡',
            'ah': '🂱',
            'ad': '🃁',
            'ac': '🃑',
            '2s': '🂢',
            '2h': '🂲',
            '2d': '🃂',
            '2c': '🃒',
            '3s': '🂣',
            '3h': '🂳',
            '3d': '🃃',
            '3c': '🃓',
            '4s': '🂤',
            '4h': '🂴',
            '4d': '🃄',
            '4c': '🃔',
            '5s': '🂥',
            '5h': '🂵',
            '5d': '🃅',
            '5c': '🃕',
            '6s': '🂦',
            '6h': '🂶',
            '6d': '🃆',
            '6c': '🃖',
            '7s': '🂧',
            '7h': '🂷',
            '7d': '🃇',
            '7c': '🃗',
            '8s': '🂨',
            '8h': '🂸',
            '8d': '🃈',
            '8c': '🃘',
            '9s': '🂩',
            '9h': '🂹',
            '9d': '🃉',
            '9c': '🃙',
            'ts': '🂪',
            'th': '🂺',
            'td': '🃊',
            'tc': '🃚',
            'js': '🂫',
            'jh': '🂻',
            'jd': '🃋',
            'jc': '🃛',
            'qs': '🂭',
            'qh': '🂽',
            'qd': '🃍',
            'qc': '🃝',
            'ks': '🂮',
            'kh': '🂾',
            'kd': '🃎',
            'kc': '🃞',
        },
    };
}

function createGame(keyboard) {
    const world = createWorld();
    const [cw, ch] = world.getBounds();
    const cardH = Math.round(ch * 0.3);
    const cardBlock = createCardBlock(cardH, cw, cardH, onCardClick);
    world.add(cardBlock);
    const balanceTF = createTextView('', cw / 2, cardH / 3, {
        fill: 'white',
        fontSize: 42,
    });
    world.add(balanceTF);

    const infoTF = createTextView('', cw / 2, cardH / 1.5, {
        fill: 'white',
        fontSize: 42,
    });
    world.add(infoTF);

    const actionButton = createButton(
        cw / 2,
        cardH * 2.5,
        400,
        80,
        'Place a bet',
        onAction
    );
    world.add(actionButton);

    let bet = 1;
    let balance = 404;
    let deck;
    let cardsToReplace;
    let isComplete;
    let lockKeyboard;

    return { init };

    function init() {
        cardBlock.init();
        setBalanceText();
        toNextRound();
    }

    function enableControls() {
        lockKeyboard = keyboard.subscribe(onKey);
        actionButton.setInteractive(true);
    }

    function disableControls() {
        lockKeyboard();
        actionButton.setInteractive(false);
    }

    function placeBet() {
        disableControls();
        isComplete = false;
        cardsToReplace = [];
        balance -= bet;
        deck = createDeck();
        const cards = deck.deal(5);
        cardBlock.setCards(cards).then(enableControls);
        setBalanceText();
        infoTF.setText('');
        actionButton.setText('Play');
    }

    function setBalanceText() {
        const { errors } = getConstants();
        const err = errors[balance];
        const add = err ? ` (${err})` : '';
        balanceTF.setText(`Balance: ${balance}${add}`);
    }

    function adjustBalance(actual) {
        return 404 + ((actual - 418) % 14);
    }

    function confirmSelection() {
        const hand = cardBlock.getCards();
        const [name, win] = rateHand(hand);
        balance += win;
        setBalanceText();
        if (win) {
            infoTF.setText(`${name}, win ${win}`);
        } else {
            infoTF.setText('Better luck next time');
        }
        setTimeout(onComplete, 1000);
    }

    function onAction() {
        if (isComplete) {
            placeBet();
        } else {
            disableControls();
            replaceCards();
            confirmSelection();
        }
    }

    function toNextRound() {
        isComplete = true;
        enableControls();
        actionButton.setText('Place a bet');
        // infoTF.setText('');
    }

    function onComplete() {
        if (balance > 418) {
            balance = adjustBalance(balance);
            setBalanceText();
            toNextRound();
        } else if (balance < 418) {
            toNextRound();
        } else {
            infoTF.setText('You won');
        }
    }

    function prepareDraw(index) {
        const i = cardsToReplace.indexOf(index);
        if (i === -1) {
            cardsToReplace.push(index);
            cardBlock.selectCard(index);
        }
    }

    function replaceCards() {
        if (cardsToReplace.length) {
            const drawCards = deck.deal(cardsToReplace.length);
            const drawData = cardsToReplace.map((index, i) => [
                index,
                drawCards[i],
            ]);
            cardBlock.replaceCards(drawData);
        }
    }

    function onCardClick(i) {
        if (!isComplete && i >= 0 && i < 5) {
            prepareDraw(i);
        }
    }

    function onKey(e) {
        if (!isComplete && e.isDigit && e.digit > 0 && e.digit < 6) {
            prepareDraw(e.digit - 1);
        } else if (e.isSpace) {
            onAction();
        }
    }
}

function createHelp() {
    const help = document.querySelector('.help-outer');
    let isShown = true;

    return { toggle };

    function toggle() {
        isShown = !isShown;
        help.style.display = isShown ? 'table' : 'none';
    }
}

roundRectPolyfill();
const keyboard = createKeyboard();
const game = createGame(keyboard);
const help = createHelp();
keyboard.subscribe(onKey);

let isFirstRun = true;

function onKey(e) {
    if (e.isEscape) {
        if (isFirstRun) {
            isFirstRun = false;
            game.init();
        }
        help.toggle();
    }
}

function createKeyboard() {
    let listeners = {};
    let keys = [];

    window.addEventListener('keyup', handleKeyUp);

    return {
        subscribe,
        reset,
    };

    function reset() {
        listeners = {};
        keys = [];
    }

    function handleKeyUp(e) {
        const dig = Number(e.key);
        const event = {};
        if (isSpace(e.key)) {
            event.isSpace = true;
        } else if (isDigit(dig)) {
            event.digit = dig;
            event.isDigit = true;
        } else {
            event[`is${e.key}`] = true;
        }
        keys.forEach((key) => listeners[key] && listeners[key](event));
    }

    function subscribe(listener) {
        const key = Date.now();
        listeners[key] = listener;
        keys = Object.keys(listeners);

        return function () {
            delete listeners[key];
            keys = Object.keys(listeners);
        };
    }

    function isDigit(value) {
        return Number.isInteger(value);
    }

    function isSpace(value) {
        return value === ' ';
    }
}

function roundRectPolyfill() {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) {
            r = w / 2;
        }
        if (h < 2 * r) {
            r = h / 2;
        }
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    };
}

function createWorld() {
    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    let objects = [];
    let dynamicObjects = [];
    let mouseListeners = [];

    canvas.addEventListener('click', onClick);

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.lineJoin = 'round';

    requestAnimationFrame(loop);

    return {
        getBounds,
        add,
        reset,
    };

    function getBounds() {
        return [canvas.width, canvas.height];
    }

    function add(obj) {
        obj.setContext(ctx);
        objects.push(obj);
        if (typeof obj.mouseListener === 'function') {
            mouseListeners.push(obj.mouseListener);
        }
    }

    function onClick(e) {
        const mouse = getMousePosition(e);
        mouseListeners.forEach((listener) => listener(mouse));
    }

    function getMousePosition(e) {
        const bcr = canvas.getBoundingClientRect();
        return {
            x: e.pageX - bcr.left,
            y: e.pageY - bcr.top,
        };
    }

    function reset() {
        objects = [];
        dynamicObjects = [];
    }

    function loop(t) {
        update(t);
        clear();
        render();
        requestAnimationFrame(loop);
    }

    function clear() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function update(t) {
        dynamicObjects.forEach((obj) => obj.update(t));
    }

    function render() {
        objects.forEach((obj) => obj.render());
    }
}

function createCard(rank, suit) {
    const { stringMap, ranks, colors } = getConstants();
    return {
        rank,
        suit,
        value: ranks.indexOf(rank),
        string: stringMap[rank + suit],
        color: colors[suit],
    };
}

function createDeck() {
    const { suits, ranks } = getConstants();
    const cards = suits.reduce((result, suit) => {
        const cardsWithRank = ranks.map((rank) => createCard(rank, suit));
        return [...result, ...cardsWithRank];
    }, []);

    for (let i = cards.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [cards[i], cards[j]] = [cards[j], cards[i]];
    }

    function deal(num) {
        return cards.splice(num * -1);
    }

    return { deal };
}

function rateHand(cards) {
    const { hands } = getConstants();
    const pool = [...cards].sort(valueComparator);
    let isStraight = true;
    let isFlush = true;

    const kinds = pool.reduce((result, card, index) => {
        if (isStraight && index !== 0) {
            isStraight = card.value === pool[index - 1].value - 1;
        }
        if (isFlush && index !== 0) {
            isFlush = card.suit === pool[index - 1].suit;
        }
        if (result[card.rank]) {
            result[card.rank].push(card);
        } else {
            result[card.rank] = [card];
        }
        return result;
    }, {});

    let rate = hands[0];

    const isStraightFlush = isFlush && isStraight;
    const isRoyalFlush = isStraightFlush && kinds.a && kinds.a.length === 1;
    if (isRoyalFlush) {
        rate = hands[9];
    } else if (isStraightFlush) {
        rate = hands[8];
    } else if (isFlush) {
        rate = hands[5];
    } else if (isStraight) {
        rate = hands[4];
    } else {
        const rb /* repetition buckets*/ = Object.keys(kinds).reduce(
            (result, rank) => {
                const len = kinds[rank].length;
                result[len].push(kinds[rank]);
                return result;
            },
            { '1': [], '2': [], '3': [], '4': [] }
        );

        if (rb['4'].length === 1) {
            rate = hands[7];
        } else if (rb['2'].length === 1 && rb['3'].length === 1) {
            rate = hands[6];
        } else if (rb['3'].length === 1) {
            rate = hands[3];
        } else if (rb['2'].length === 2) {
            rate = hands[2];
        } else if (rb['2'].length === 1) {
            const isBetter = rb['2'][0].every((card) => card.value > 8);
            if (isBetter) {
                rate = hands[1];
            }
        }
    }

    return rate;

    function valueComparator(card1, card2) {
        if (card1.value < card2.value) {
            return 1;
        }
        if (card1.value > card2.value) {
            return -1;
        }
        return 0;
    }
}

function createBetBlock(x, y, r) {
    let ctx;
    const gap = Math.round(r * 0.1);
    const coinsViews = [createCoinView(x, y, r)];

    return {
        setContext,
        render,
        addCoin,
        removeCoin,
    };

    function addCoin() {
        const cx = x + coinsViews.length * (2 * r + gap);
        const coinView = createCoinView(cx, y, r);
        coinView.setContext(ctx);
        coinsViews.push(coinView);
    }

    function removeCoin() {
        coinsViews.pop();
    }

    function render() {
        coinsViews.forEach((view) => view.render());
    }

    function setContext(c) {
        ctx = c;
        coinsViews.forEach((view) => view.setContext(c));
    }
}

function createButton(cx, cy, w, h, text, listener) {
    let ctx;
    let isInteractive = false;
    const x = cx - w / 2;
    const y = cy - h / 2;
    const r = Math.round(h * 0.1);

    return {
        render,
        setContext,
        setText,
        mouseListener,
        setInteractive,
    };

    function setInteractive(isActive) {
        isInteractive = isActive;
    }

    function setText(t) {
        text = t;
    }

    function mouseListener(point) {
        if (isInteractive && isPointInside(point)) {
            listener();
        }
    }

    function isPointInside(point) {
        return inRange(point.x, x, x + w) && inRange(point.y, y, y + h);
    }

    function inRange(value, min, max) {
        return value >= Math.min(min, max) && value <= Math.max(min, max);
    }

    function render() {
        ctx.save();
        ctx.fillStyle = '#C35B68';
        ctx.roundRect(x, y, w, h, r);
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = `${h / 2}px fantasy`;
        ctx.fillText(text, cx, cy);
        ctx.restore();
    }

    function setContext(c) {
        ctx = c;
    }
}

function createCardBlock(cardHeight, canvasWidth, y, onCardClick) {
    let ctx;
    let cardViews = [];
    const margin = Math.round(cardHeight * 0.06);
    const cardWidth = Math.round(cardHeight * 0.66);

    return {
        setContext,
        render,
        selectCard,
        replaceCards,
        getCards,
        setCards,
        init,
        mouseListener,
    };

    function mouseListener(mouse) {
        let i = 0;
        for (; i < 5; i++) {
            if (cardViews[i].isPointInside(mouse)) {
                break;
            }
        }
        onCardClick(i);
    }

    function init() {
        const bw = margin + 5 * (cardWidth + margin);
        const x = (canvasWidth - bw) / 2;
        cardViews = Array.from({ length: 5 }, (_, i) => {
            const cx = x + i * (cardWidth + margin);
            const view = createCardView(cx, y, cardWidth, cardHeight, margin);
            view.setContext(ctx);
            return view;
        });
    }

    function setCards(cards) {
        cardViews.forEach((view, i) => {
            view.setSelected(true);
            view.setCard(cards[i]);
        });

        return new Promise((resolve) => {
            setTimeout(() => {
                cardViews.forEach((view) => view.setSelected(false));
                resolve();
            }, 500);
        });
    }

    function render() {
        cardViews.forEach((view) => view.render());
    }

    function setContext(c) {
        ctx = c;
    }

    function selectCard(index) {
        cardViews[index].setSelected(true);
    }

    function replaceCards(drawData) {
        drawData.forEach(([index, card]) => {
            cardViews[index].setCard(card);
            cardViews[index].setSelected(false);
        });
    }

    function getCards() {
        return cardViews.map((view) => view.getCard());
    }
}

function createCardView(x, y, w, h, margin) {
    let ctx;
    let card;
    let isSelected;
    const halfMargin = margin / 2;
    const back = '🂿';

    return {
        render,
        setContext,
        setSelected,
        setCard,
        getCard,
        isPointInside,
    };

    function isPointInside(point) {
        return inRange(point.x, x, x + w) && inRange(point.y, y, y + h);
    }

    function inRange(value, min, max) {
        return value >= Math.min(min, max) && value <= Math.max(min, max);
    }

    function render() {
        ctx.save();
        ctx.fillStyle = 'white';
        ctx.roundRect(x, y, w, h - halfMargin, halfMargin);
        ctx.fill();
        ctx.font = `${h}px sans-serif`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        const isBack = isSelected || !card;
        ctx.fillStyle = isBack ? '#DCB600' : card.color;
        const text = isBack ? back : card.string;
        ctx.fillText(text, x, y + margin);

        ctx.restore();
    }

    function setCard(cd) {
        card = cd;
    }

    function getCard() {
        return card;
    }

    function setSelected(isSel) {
        isSelected = isSel;
    }

    function setContext(c) {
        ctx = c;
    }
}

function createCoinView(x, y, r) {
    let ctx;

    return {
        render,
        setContext,
    };

    function render() {
        ctx.save();
        ctx.strokeStyle = 'green';
        ctx.fillStyle = 'yellow';
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2, false);
        ctx.fill();
        ctx.font = `bold ${r * 2}px sans-serif`;
        ctx.fillStyle = 'white';
        ctx.fillText('$', x, y + 5);
        ctx.strokeText('$', x, y + 5);

        ctx.restore();
    }

    function setContext(c) {
        ctx = c;
    }
}

function createTextView(text, x, y, style) {
    let ctx;
    const { fontSize, fill, stroke } = style;

    return {
        render,
        setContext,
        setText,
    };

    function setText(t) {
        text = t;
    }

    function render() {
        ctx.save();
        ctx.font = `${fontSize}px fantasy`;
        ctx.fillStyle = fill;
        ctx.fillText(text, x, y);
        if (stroke) {
            ctx.strokeStyle = stroke;
            ctx.strokeText(text, x, y);
        }
        ctx.restore();
    }

    function setContext(c) {
        ctx = c;
    }
}
